---
title: |
  Why shouldn't you use numerical tests to diagnose the linear regression models?
type: ARTICLE TEMPLATE
author:
  - name: Weihao Li
    affil: a
    email: weihao.li@monash.edu
  - name: Dianne Cook
    affil: a
    email: dicook@monash.edu
  - name: Emi Tanaka
    affil: a
    email: emi.tanaka@monash.edu
affiliation:
  - num: a
    address: |
      Department of Econometrics and Business Statistics, Monash University, Clayton, VIC, Australia
bibliography: paper.bib
abstract: |
  Abstract to fill.
keywords: |
  visual inference; model diagnostics;
header-includes: |
  \usepackage{hyperref}
  \usepackage[utf8]{inputenc}
  \def\tightlist{}
output: rticles::tf_article
---

problem: residual plot diagnostics
conventional test: too sensitive

background: 

<!-- week 1 -->
1. residual plot for model diagnostics

a. residual is widely used
b. what are the types of residual plots
c. comparison

<!-- week 2 -->
2. conventional test: F, BP
3. visual test: lineup, theory

<!-- week 4 -->
desc of experiment:
1. simulation setup
2. experimental design
3. result

<!-- week 3 -->
comparison of conventional tests:
1. power (visual test vs. conventional test)
(visual test most different one (everything test, any departure))
plot figure in a paper, desc, exp
2. investigate the difference (gap), give examples
3. conventional is too sensitive
4. make conventional less sensitive (vary alpha)


<!-- last week -->
conclusion:
1. too sensitive, visual test is needed/preferable
2. visual test is infeasible in large scale (expensive)
3. future work (role of computer vision)

# Introduction

Regression diagnostics conventionally involve evaluating the fitness of the proposed model, detecting the presence of influential observations and outliers, checking the validity of model assumptions and many more. Common diagnostic techniques including summary statistics, hypothesis testing, and data plots are essential tools for a systematic and detailed examination of the regression model [@mansfield1987diagnostic].

## Diagnostic plots

Regression analysis is a field of study with at least a hundred years of history. Many of those regression diagnostic methods and procedures are mature and well-established in books first published in the twentieth century, such as @draper_applied_2014, @montgomery_introduction_2012, @belsley_regression_1980, @cook_applied_1999 and @cook1982residuals. Regardless of the level of difficulty of the book, one will find the importance and usefulness of diagnostic plots being emphasized again and again. Checking diagnostic plots is also the recommended starting point for validating model assumptions like normality, homoscedasticity and linearity [@anscombe_examination_1963]. 

Graphical summaries in which residuals are plotted against fitted values or other functions of the predictor variables that are approximately orthogonal to residuals are refereed to as standard residual plots. They are commonly used to identify patterns which are indicative of nonconstant error variance or non-linearity [@cook1982residuals]. Raw residuals and studentized residuals are the two most frequently used residuals in standard residual plots. The debt on which type of residuals should be used always present. While raw residuals are the most common output of computer regression software package, by applying a scaling factor, the ability of revealing nonconstant error variance in standard residual plots will often be enhanced by studentized residuals in small sample size [@gunst2018regression]. 

As a two-dimensional representation of a model in a $p$-dimensional space, standard residual plots project  data points onto the variable of the horizontal axis, which is a vector in $p$-dimensional space. Observations with the same projection will be treated as equivalent as they have the same position of the abscissa. Therefore, standard residual plots are often useful in revealing model inadequacies in the direction of the variable of the horizontal axis, but could be inadequate for detecting patterns in other directions, especially in those perpendicular to the variable of the horizontal axis. Hence, in practice, multiple standard residual plots with different horizontal axes will be examined.


<!-- large sample size-->
Overlapping data points is a general issue in scatter plots not limited to standard residual plots, which often makes plots difficult to interpret because visual patterns are concealed. Thus, for relatively large sample size, @cleveland1975graphical suggests the use of robust moving statistics as reference lines to give aids to eye in seeing patterns, which nowadays, are usually replaced with a spline or local polynomial regression line.

Other types of data plots that are often used in regression diagnostics include partial residual plots and probability plots. Partial residual plots are useful supplements to standard residual plots as they provide additional information on the extent of the non-linearity. Probability plots can be used to compare the sampling distribution of the residuals to the normal distribution for assessing the normality assumptions.

## Hypothesis testing

In addition to diagnostic plots, researcher may also perform formal tests for detecting model defects. Depends on the alternative, variety of tests can be applied. For example, for testing heteroskedasticity, 
one may use the White test [@white_heteroskedasticity-consistent_1980] or the Breusch-Pagan test [@breusch_simple_1979]. And for testing non-linearity, there are RESET test [@ramsey_tests_1969] and F-test.  

As discussed in @cook1982residuals, most residual based tests for a particular type of departures from model assumptions are sensitive to other types of departures. Especially, outliers will often  incorrectly trigger the rejection of null hypothesis despite the residuals are well-behaved [@cook_applied_1999]. This can be largely avoided in diagnostic plots as experienced analysts can evaluate the acceptability of assumptions flexibly, even in the presence of outliers. Furthermore, @montgomery_introduction_2012 stated that based on their experience, statistical tests are not widely used in regression diagnostics. Most importantly, the same or even larger amount of information can be provided by diagnostic plots than the corresponding tests in most empirical studies. But still, the effectiveness of statistical tests shall not be disrespected. Statistical tests have chance to provide analysts with unique information. There are also situations where no suitable diagnostic plots can be found for a particular violation of the assumptions, or excessive diagnostic plots need to be checked. One will have no choice but to rely on statistical tests if there is any. A good regression diagnostic practice should be a combination of both methods.

## Visual inference

Diagnostic plots are 

<!-- However, unlike confirmatory data analysis built upon rigorous statistical procedures, e.g., hypothesis testing, visual diagnostics relies on graphical perception - human’s ability to interpret and decode the information embedded in the graph [@cleveland_graphical_1984], which is to some extent subjective. Further, visual discovery suffers from its unsecured and unconfirmed nature where the degree of the presence of the visual features typically can not be measured quantitatively and objectively, which may lead to over or under-interpretations of the data. One such example is finding an over-interpretation of the separation between gene groups in a two-dimensional projection from a linear discriminant analysis when in fact there are no differences in the expression levels between the gene groups and separation is not an uncommon occurrence [@roy_chowdhury_using_2015]. -->

<!-- Recently, a new branch of statical inference  -->

<!-- Visual inference was first introduced in a 1999 Joint Statistical Meetings (JSM) talk with the title "Inference for Data Visualization" by @buja_inference_1999 as an idea to address the issue of valid inference for visual discoveries of data plots [@gelman_exploratory_2004]. Later, in the Bayesian context, data plots was systematically considered as model diagnostics by taking advantage of the data simulated from the assumed statistical models [@gelman_bayesian_2003; @gelman_exploratory_2004].  -->


# Experimental design

# Data processing


# Results

## Overview of the Data

We collected 400 lineup evaluations made by 20 participants in experiment I and 880 lineup evaluations made by 44 participants in experiment II. In total, 442 unique lineups were evaluated by 64 subjects. In experiment I, one of the participants skipped all 20 lineups. Hence, the submission was rejected and removed from the dataset. In experiment II, there was a participant failed one of the two attention checks, but there was no further evidence of low-effort throughout the experiment. Therefore, the submission was kept.



## Power comparision

1. power (visual test vs. conventional test)
(visual test most different one (everything test, any departure))
plot figure in a paper, desc, exp
2. investigate the difference (gap), give examples
3. conventional is too sensitive
4. make conventional less sensitive (vary alpha)


To model the power of visual test, 10 logistic regression were fit for different number of evaluations ranged from one to five and two different types of simulation setting. All 10 models used natural logarithm of the effect size as the only fixed effect, and whether the test successfully rejects the null hypothesis as the response variable. Given the way we define the effect size, it was expected that with larger effect size, both conventional test and visual test will have higher probability in rejecting the null hypothesis when it is not true. The modelling result summarized in \ref{tab:powerglmcubic} and \ref{tab:powerglmheter} aligned with the expectation as the coefficients of natural logarithm of the effect size are positive and significant across all 10 models.


Figure \ref{fig:power-com} illustrates the fitted models, while providing the local constant estimate of the power of F-test and Breusch–Pagan test for comparison. Data for the conventional test is simulated under the model setting described in section ... and 5000000 samples are drawn for both cubic and heteroskedasticity model. From Figure \ref{fig:power-com}, it can be observed that the fitted power of visual test increased as the number of evaluations increased for both cubic and heteroskedasticity model.

For heteroskedasticity model, this phenomenon was more obvious as the power of visual tests with evaluations greater than two were always greater than those with evaluations smaller than two. 

For cubic model, the separation between curves was small. The estimated power of visual tests with three to five evaluations were almost identical to each other in regards of effect size. In addition, all five curves peaked at one as effect size increased, suggesting that identification of non-linearity as a visual task can be completed reliably by human as long as the departure from null hypothesis is large enough.

As shown in Figure \ref{fig:power-com}, both F-test and Breusch–Pagan test generally possessed greater power than visual test. A visual tests is a collection of test against any alternatives that would create visual discoverable features, while a conventional test is usually targeting at a pre-specified alternative. Considering the data generating process of the model defect was known and controlled in this research, where all other alternatives have been eliminated except the one we concerned, the result was suggested that conventional tests were more sensitive to violations of linearity and homoscedasticity assumption than visual tests. 

It was also found that there was a noticeable gap between curves of the conventional test and the visual test at around $log(\text{effect size}) = 0$ for the cubic model and $log(\text{effect size}) = 2.5$ for the heteroskedasticity model, where the differences in power were greater than 0.6. We further analysed the lineups with correspoding effect sizes. Figure \ref{fig:cubic-hard} and \ref{fig:heter-hard} showed that human was indeed hard to identify the patterns at this level of difficulty. The visual difference between the true data plot and null plots were almost unnoticeable. 

## Effect of parameters on power of the visual test

The previous section focuses on the change of effect size relative to the power of the visual test. 




```{r setup, include=FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE, echo = FALSE)
```


```{r}
library(tidyverse)
library(visage)
pilot <- read_csv(here::here("data/processed/processed_pilot.csv"))
survey <- read_csv(here::here("data/processed/processed_surveys.csv"))
sim_conv <- read_csv(here::here("data/processed/sim_conv_result.csv"), col_types = "dddddcdddlcdcdddlc")
```

```{r}
survey <- survey %>%
  mutate(log_effect_size = log(effect_size))

sim_conv <- sim_conv %>%
  mutate(log_effect_size = log(effect_size))

lineup_info <- select(survey, type:answer, conventional_p_value, ori_difficulty, exp, exp_lineup_id, log_effect_size) %>%
  group_by(exp_lineup_id) %>% 
  filter(row_number() == 1) %>%
  ungroup()

write_csv(lineup_info, here::here("data/processed/processed_lineup_info.csv"))


# Local constant estimator
kernel_regression_cubic <- function(sim_conv, h = 0.3, x = quote(log_effect_size)) {
  with(filter(sim_conv, type == "cubic", log_effect_size > -5, log_effect_size < 10),
     KernSmooth::locpoly(x = eval(x), y = reject, bandwidth = h, degree = 0, gridsize = 1000)) %>%
    as_tibble() %>%
    mutate(type = "cubic", h = h) %>%
    rename(reject = y)
}

# Local constant estimator
kernel_regression_heter <- function(sim_conv, h = 0.4, x = quote(log_effect_size)) {
  with(filter(sim_conv, type != "cubic", log_effect_size > -3),
     KernSmooth::locpoly(x = eval(x), y = reject, bandwidth = h, degree = 0, gridsize = 1000)) %>%
    as_tibble() %>%
    mutate(type = "heteroskedasticity", h = h) %>%
    rename(reject = y)
}
```


```{r}
if (file.exists(here::here("data/processed/lineup_env.rds"))) {
  env <- readRDS(here::here("data/processed/lineup_env.rds"))
} else {
  env <- new.env()
}

save_lineup_env <- function(env) {
  saveRDS(env, here::here("data/processed/lineup_env.rds"))
}

survey_pvalue <- survey %>%
  calc_p_value_multi(lineup_id = "exp_lineup_id", 
                     detected = "detect", 
                     n_sel = "num_selection",
                     comb = TRUE,
                     n_eval = 1:5,
                     n_sim = 100000,
                     cache_env = env) %>%
  rename(exp_lineup_id = lineup_id) %>%
  unnest_longer(col = p_value) %>%
  left_join(lineup_info) %>%
  mutate(reject = eval_p_value(p_value, tol = 0.01))

save_lineup_env(env)
```


```{r results='asis'}
map(1:5, function(x) glm(reject ~ log_effect_size,
                         family = binomial(),
                         data = filter(survey_pvalue, n_eval == {{x}}, type == "cubic"))) %>%
  stargazer::stargazer(header = FALSE,
            label = "tab:powerglmcubic",
            title = "Logistic regressions with rejection as response variable and natural logarithm of the effect size as regressor fitted on the data collected from experiment I and II for cubic model. Five regression were fitted for different number of evaluations.",
            style = "default",
            column.labels = c("num\\_eval: 1", "num\\_eval:2", "num\\_eval: 3", "num\\_eval: 4", "num\\_eval:5"),
            model.numbers = FALSE)
```


```{r results="asis"}
map(1:5, function(x) glm(reject ~ log_effect_size,
                         family = binomial(),
                         data = filter(survey_pvalue, n_eval == {{x}}, type == "heteroskedasticity"))) %>%
  stargazer::stargazer(header = FALSE,
            label = "tab:powerglmheter",
            title = "Logistic regressions with rejection as response variable and natural logarithm of the effect size as regressor fitted on the data collected from experiment I and II for heteroskedasticity model. Five regression were fitted for different number of evaluations.",
            style = "default",
            column.labels = c("num\\_eval: 1", "num\\_eval:2", "num\\_eval: 3", "num\\_eval: 4", "num\\_eval:5"),
            model.numbers = FALSE)
```



```{r power-com, fig.cap="\\label{fig:power-com}power com"}
survey_pvalue %>%
  mutate(reject = as.numeric(reject)) %>%
  mutate(n_eval = factor(n_eval)) %>%
  ggplot() +
  geom_point(aes(log_effect_size, reject), alpha = 0.01) +
  geom_line(data = kernel_regression_cubic(sim_conv, 0.4), aes(x, reject), linetype = 2) +
  geom_line(data = kernel_regression_heter(sim_conv, 0.75), aes(x, reject), linetype = 2) +
  geom_smooth(aes(log_effect_size, reject, group = n_eval, col = n_eval),
              method = "glm", method.args = list(family = binomial), size = 0.5, se = FALSE) +
  scale_colour_viridis_d(option = "B", begin = 0.5, end = 0.9) +
  facet_wrap(~type, scales = "free_x") +
  ylab("Estimated power")
```


```{r cubic-hard, fig.cap="\\label{fig:cubic-hard}cubic-hard ans 11"}
big_lineup_dat <- readRDS(here::here("data/big_study/all_data_big.RDS"))

# ans 11, conventional 0.003491033
CUBIC_MODEL$plot_lineup(mutate(big_lineup_dat[[28]]$data, .fitted = .pred),
                        remove_axis = TRUE,
                        theme = theme_light(),
                        remove_grid_line = TRUE)

```

```{r heter-hard, fig.cap="\\label{fig:heter-hard}heter-hard ans 2"}
# ans 2, conventional 0.003535915
HETER_MODEL$plot_lineup(mutate(big_lineup_dat[[136]]$data, .fitted = .pred),
                        remove_axis = TRUE,
                        theme = theme_light(),
                        remove_grid_line = TRUE)
```

```{r power-com-cubic-a, fig.cap="\\label{fig:power-com-cubic-a}power com cubic a"}
bind_grid <- expand.grid(n = c(50, 100, 300),
                         h = 0.4,
                         x = c(quote(abs(a)/e_sigma)))

bind_list <- list()

for (i in 1:nrow(bind_grid)) {
  (function(n, h, x) {
    mutate(kernel_regression_cubic(filter(sim_conv, n == {{n}}), h = h, x = x),
           n = factor(n, levels = c(50, 100, 300)))
    })(n = bind_grid$n[i], h = bind_grid$h[i], x = bind_grid$x[[i]]) -> bind_list[[i]]
}

bind_sim <- reduce(bind_list, bind_rows)


# cubic break down
survey_pvalue %>%
  filter(type == "cubic") %>%
  mutate(n = factor(n, levels = c(50, 100, 300))) %>%
  mutate(n_eval = factor(n_eval)) %>%
  mutate(reject = as.numeric(reject)) %>%
  ggplot() +
  ggbeeswarm::geom_quasirandom(aes(abs(a)/e_sigma, reject, group = n), groupOnX = FALSE, alpha = 0.01) +
  geom_smooth(aes(abs(a)/e_sigma, reject, col = n_eval), method = "glm", method.args = list(family = binomial()), se = FALSE) +
  geom_line(data = bind_sim, aes(x, reject), col = "grey", linetype = 2, size = 1) +
  facet_wrap(~n, labeller = label_both) +
  scale_colour_viridis_d(option = "B", begin = 0.5, end = 0.9) +
  theme_light()
```



```{r power-com-cubic-b, fig.cap="\\label{fig:power-com-cubic-b}power com cubic b"}
bind_grid <- expand.grid(n = c(50, 100, 300),
                         h = 0.4,
                         x = c(quote(abs(b)/e_sigma)))

bind_list <- list()

for (i in 1:nrow(bind_grid)) {
  (function(n, h, x) {
    mutate(kernel_regression_cubic(filter(sim_conv, n == {{n}}), h = h, x = x),
           n = factor(n, levels = c(50, 100, 300)))
    })(n = bind_grid$n[i], h = bind_grid$h[i], x = bind_grid$x[[i]]) -> bind_list[[i]]
}

bind_sim <- reduce(bind_list, bind_rows)

# cubic break down
survey_pvalue %>%
  filter(type == "cubic") %>%
  mutate(n = factor(n, levels = c(50, 100, 300))) %>%
  mutate(reject = as.numeric(reject)) %>%
  mutate(n_eval = factor(n_eval)) %>%
  ggplot() +
  ggbeeswarm::geom_quasirandom(aes(abs(b)/e_sigma, reject, group = n), groupOnX = FALSE, alpha = 0.01) +
  geom_smooth(aes(abs(b)/e_sigma, reject, col = n_eval), method = "glm", method.args = list(family = binomial()), se = FALSE) +
  geom_line(data = bind_sim, aes(x, reject), col = "grey", linetype = 2, size = 1) +
  facet_wrap(~n, labeller = label_both) +
  scale_colour_viridis_d(option = "B", begin = 0.5, end = 0.9) +
  theme_light()
```

```{r eval = FALSE}
# cubic break down
# We do not have enough observations
survey_pvalue %>%
  filter(type == "cubic") %>%
  mutate(n = factor(n)) %>%
  mutate(reject = as.numeric(reject)) %>%
  ggplot() +
  geom_point(aes(abs(a), reject, col = n), alpha = 0.1) +
  geom_smooth(aes(abs(a), reject, col = n), method = "glm", method.args = list(family = binomial()), se = FALSE) +
  geom_smooth(data = mutate(filter(sim_conv, type == "cubic"), n = factor(n), reject = as.numeric(reject)),
              aes(abs(a), reject, group = n), 
              method = "glm", method.args = list(family = binomial()), se = FALSE, col = "grey", linetype = 2) +
  facet_grid(e_sigma~n)
```


```{r power-com-heter-b, fig.cap="\\label{fig:power-com-heter-b}power com heter b"}
bind_grid <- expand.grid(n = c(50, 100, 300),
                         h = 3,
                         x = c(quote(b)),
                         a = c(-1, 0, 1))

bind_list <- list()

for (i in 1:nrow(bind_grid)) {
  (function(n, h, x, a) {
    mutate(kernel_regression_heter(filter(sim_conv, n == {{n}}, a == {{a}}), h = h, x = x),
           n = factor(n, levels = c(50, 100, 300)),
           a = factor(a, levels = c(-1, 0, 1)))
    })(n = bind_grid$n[i], h = bind_grid$h[i], x = bind_grid$x[[i]], a = bind_grid$a[i]) -> bind_list[[i]]
}

bind_sim <- reduce(bind_list, bind_rows)

# heter break down
survey_pvalue %>%
  filter(type != "cubic") %>%
  mutate(n = factor(n, levels = c(50, 100, 300))) %>%
  mutate(reject = as.numeric(reject)) %>%
  mutate(n_eval = factor(n_eval)) %>%
  ggplot() +
  ggbeeswarm::geom_quasirandom(aes(b, reject, group = n), groupOnX = FALSE, alpha = 0.01) +
  geom_smooth(aes(b, reject, col = n_eval), method = "glm", method.args = list(family = binomial()), se = FALSE) +
  geom_line(data = bind_sim, aes(x, reject), col = "grey", linetype = 2, size = 1) +
  theme_light() +
  scale_colour_viridis_d(option = "B", begin = 0.5, end = 0.9) +
  facet_grid(a~n, labeller = label_both)
```


